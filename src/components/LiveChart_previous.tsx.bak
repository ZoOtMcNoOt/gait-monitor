import { useEffect, useRef, useState, useCallback } from 'react'
import { 
  Chart, 
  LineController, 
  LineElement, 
  PointElement, 
  LinearScale, 
  TimeScale,
  Title,
  Tooltip,
  Legend
} from 'chart.js'
import { useDeviceConnection } from '../contexts/DeviceConnectionContext'

Chart.register(
  LineController, 
  LineElement, 
  PointElement, 
  LinearScale, 
  TimeScale,
  Title,
  Tooltip,
  Legend
)

interface Props {
  isCollecting?: boolean
}

interface GaitData {
  device_id: string
  R1: number
  R2: number
  R3: number
  X: number
  Y: number
  Z: number
  timestamp: number
}

interface GaitDataPayload {
  device_id: string,
  r1: number, r2: number, r3: number,
  x: number, y: number, z: number,
  timestamp: number
}

const CHART_COLORS = {
  R1: '#ef4444', // red
  R2: '#f97316', // orange
  R3: '#eab308', // yellow
  X: '#22c55e',  // green
  Y: '#3b82f6',  // blue  
  Z: '#8b5cf6'   // purple
} as const

export default function LiveChart({ isCollecting = false }: Props) {
  // Chart state
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const chartRef = useRef<Chart | null>(null)
  const [chartMode, setChartMode] = useState<'all' | 'resistance' | 'acceleration'>('all')
  
  // Use global device connection context
  const { 
    connectedDevices, 
    activeCollectingDevices,
    connectionStatus, 
    deviceHeartbeats,
    subscribeToGaitData,
    lastGaitDataTime,
    gaitDataBuffer
  } = useDeviceConnection()
  
  // Store data per device and timing reference
  const deviceDataBuffers = useRef<Map<string, GaitData[]>>(new Map())
  const baseTimestamp = useRef<number | null>(null)

  // Function to update chart datasets for a specific device
  const updateChartForDevice = useCallback((deviceId: string, gaitData: GaitData) => {
    if (!chartRef.current) return

    const chart = chartRef.current
    const deviceLabel = deviceId === 'simulation' ? 'Sim' : `Device ${deviceId.slice(-4)}`
    
    // Device color mapping for multi-device support
    const deviceColors = [
      '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899',
      '#06b6d4', '#84cc16', '#f97316', '#6366f1', '#14b8a6', '#eab308'
    ]
    
    const getDeviceColor = (baseColor: string) => {
      const deviceIndex = [...deviceDataBuffers.current.keys()].indexOf(deviceId)
      
      // If it's the first device or simulation, use base colors
      if (deviceIndex === 0 || deviceId === 'simulation') {
        return baseColor
      }
      
      // For other devices, use device-specific colors while maintaining channel relationships
      const modifier = deviceIndex % deviceColors.length
      return deviceColors[modifier]
    }
    
    // Helper function to find or create dataset
    const findOrCreateDataset = (color: string, fullLabel: string) => {
      const label = `${deviceLabel} - ${fullLabel}`
      let dataset = chart.data.datasets.find(ds => ds.label === label)
      
      if (!dataset) {
        const finalColor = getDeviceColor(color)
        dataset = {
          label,
          data: [],
          borderColor: finalColor,
          backgroundColor: finalColor + '20',
          tension: 0.1,
          pointRadius: 0,
          borderWidth: 2
        }
        chart.data.datasets.push(dataset)
        console.log(`üìä Created new dataset: ${label} (total datasets: ${chart.data.datasets.length})`)
      }
      
      return dataset
    }

    // Initialize base timestamp on first data point from any device
    if (baseTimestamp.current === null) {
      baseTimestamp.current = gaitData.timestamp
      console.log('üìè Base timestamp set:', baseTimestamp.current, 'for device:', deviceId)
    }
    
    // Convert to relative time from base timestamp (in seconds)
    const relativeTime = (gaitData.timestamp - baseTimestamp.current) / 1000
    const normalizedGaitData = { 
      ...gaitData, 
      timestamp: relativeTime 
    }
    
    // Debug logging for timing analysis
    console.log(`üìä Device ${deviceId}: Raw timestamp: ${gaitData.timestamp}, Relative time: ${relativeTime.toFixed(3)}s`)

    // Update datasets based on current mode
    if (chartMode === 'all' || chartMode === 'resistance') {
      const r1Dataset = findOrCreateDataset(CHART_COLORS.R1, 'R1 (Resistance)')
      const r2Dataset = findOrCreateDataset(CHART_COLORS.R2, 'R2 (Resistance)')
      const r3Dataset = findOrCreateDataset(CHART_COLORS.R3, 'R3 (Resistance)')
      
      r1Dataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.R1 })
      r2Dataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.R2 })
      r3Dataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.R3 })
      
      // Time-based data retention: keep data from last 10 seconds
      const cutoffTime = normalizedGaitData.timestamp - 10
      r1Dataset.data = (r1Dataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
      r2Dataset.data = (r2Dataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
      r3Dataset.data = (r3Dataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
    }
    
    if (chartMode === 'all' || chartMode === 'acceleration') {
      const xDataset = findOrCreateDataset(CHART_COLORS.X, 'X (Accel)')
      const yDataset = findOrCreateDataset(CHART_COLORS.Y, 'Y (Accel)')
      const zDataset = findOrCreateDataset(CHART_COLORS.Z, 'Z (Accel)')
      
      xDataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.X })
      yDataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.Y })
      zDataset.data.push({ x: normalizedGaitData.timestamp, y: gaitData.Z })
      
      // Time-based data retention: keep data from last 10 seconds
      const cutoffTime = normalizedGaitData.timestamp - 10
      xDataset.data = (xDataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
      yDataset.data = (yDataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
      zDataset.data = (zDataset.data as Array<{ x: number; y: number }>).filter(point => point.x >= cutoffTime)
    }

    chart.update('none')
    
    // Get or create device buffer
    if (!deviceDataBuffers.current.has(deviceId)) {
      deviceDataBuffers.current.set(deviceId, [])
      console.log('üì± New device added:', deviceId, 'at relative time:', relativeTime.toFixed(3) + 's')
    }
    
    const deviceBuffer = deviceDataBuffers.current.get(deviceId)!
    deviceBuffer.push(normalizedGaitData)
    
    // Keep only last 10 seconds at 100Hz per device (increased from 5 to 10 seconds)
    if (deviceBuffer.length > 1000) {
      deviceBuffer.shift()
    }
    
    // Debug logging for multi-device data retention
    if (deviceBuffer.length % 100 === 0) { // Log every 100 points
      console.log(`üìà Device ${deviceId}: ${deviceBuffer.length} points buffered, latest timestamp: ${normalizedGaitData.timestamp.toFixed(2)}s`)
      
      // Also log chart dataset info
      const deviceDatasets = chartRef.current?.data.datasets.filter(ds => ds.label?.includes(deviceId.slice(-4)))
      console.log(`üìä Device ${deviceId} chart datasets:`, deviceDatasets?.map(ds => ({ 
        label: ds.label, 
        points: ds.data.length,
        firstTime: ds.data.length > 0 ? (ds.data[0] as { x: number; y: number })?.x : 'none',
        lastTime: ds.data.length > 0 ? (ds.data[ds.data.length - 1] as { x: number; y: number })?.x : 'none'
      })))
    }
  }, [chartMode])

  // Initialize chart
  useEffect(() => {
    if (!canvasRef.current) return

    const ctx = canvasRef.current.getContext('2d')
    if (!ctx) return

    chartRef.current = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: []
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: {
          intersect: false,
        },
        plugins: {
          title: {
            display: true,
            text: 'Live Gait Data'
          },
          legend: {
            display: true,
            position: 'top'
          }
        },
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            title: {
              display: true,
              text: 'Time (seconds)'
            }
          },
          y: {
            title: {
              display: true,
              text: 'Value'
            }
          }
        }
      }
    })

    return () => {
      if (chartRef.current) {
        chartRef.current.destroy()
        chartRef.current = null
      }
    }
  }, [])

  // Subscribe to gait data from context
  useEffect(() => {
    const unsubscribe = subscribeToGaitData((payload: GaitDataPayload) => {
      const gaitData = convertPayloadToGaitData(payload)
      
      // Store data in buffer for this device
      if (!deviceDataBuffers.current.has(gaitData.device_id)) {
        deviceDataBuffers.current.set(gaitData.device_id, [])
      }
      
      const buffer = deviceDataBuffers.current.get(gaitData.device_id)!
      buffer.push(gaitData)
      
      // Keep only last 1000 data points per device
      if (buffer.length > 1000) {
        deviceDataBuffers.current.set(gaitData.device_id, buffer.slice(-1000))
      }
      
      // Update chart
      updateChartForDevice(gaitData.device_id, gaitData)
    })

    return unsubscribe
  }, [subscribeToGaitData, convertPayloadToGaitData, updateChartForDevice])

  // Generate simulation data when collecting but no real data
  useEffect(() => {
    if (!isCollecting || activeCollectingDevices.length > 0) return

    const interval = setInterval(() => {
      const now = Date.now() / 1000
      const simulationData: GaitData = {
        device_id: 'simulation',
        R1: 12 + Math.sin(now * 2) * 3 + Math.random() * 0.5,
        R2: 15 + Math.cos(now * 1.5) * 2 + Math.random() * 0.3,
        R3: 18 + Math.sin(now * 0.8) * 4 + Math.random() * 0.4,
        X: Math.sin(now * 3) * 2 + Math.random() * 0.2,
        Y: Math.cos(now * 2.5) * 1.5 + Math.random() * 0.15,
        Z: 9.8 + Math.sin(now * 1.2) * 0.5 + Math.random() * 0.1,
        timestamp: now
      }
      
      updateChartForDevice('simulation', simulationData)
    }, 50) // 20 Hz simulation

    return () => clearInterval(interval)
  }, [isCollecting, activeCollectingDevices.length, updateChartForDevice])

  // Clear chart when stopping collection
  useEffect(() => {
    if (!isCollecting && chartRef.current) {
      chartRef.current.data.datasets = []
      chartRef.current.update()
      deviceDataBuffers.current.clear()
      baseTimestamp.current = null
    }
  }, [isCollecting])

  return (
    <div className="live-chart-container">
      <div className="chart-controls">
        <div className="chart-mode-selector">
          <label>Chart Mode:</label>
          <select 
            value={chartMode} 
            onChange={(e) => setChartMode(e.target.value as 'all' | 'resistance' | 'acceleration')}
            title="Select chart display mode"
          >
            <option value="all">All Channels</option>
            <option value="resistance">Resistance Only</option>
            <option value="acceleration">Acceleration Only</option>
          </select>
        </div>
        
        <div className="connection-status">
          <h4>Device Status</h4>
          {connectedDevices.length === 0 ? (
            <p>No devices connected</p>
          ) : (
            <ul>
              {connectedDevices.map(deviceId => {
                const status = connectionStatus.get(deviceId)
                const heartbeat = deviceHeartbeats.get(deviceId)
                const isCollecting = activeCollectingDevices.includes(deviceId)
                
                return (
                  <li key={deviceId} className={`device-status ${status}`}>
                    <span className="device-id">{deviceId.slice(-8)}</span>
                    <span className={`status-indicator ${status}`}>
                      {status === 'connected' ? 'üü¢' : status === 'timeout' ? 'üü°' : 'üî¥'}
                    </span>
                    {heartbeat && (
                      <span className="heartbeat-info">‚ô•{heartbeat.sequence}</span>
                    )}
                    {isCollecting && <span className="collecting-indicator">üìä</span>}
                  </li>
                )
              })}
            </ul>
          )}
        </div>
      </div>
      
      <div className="chart-wrapper">
        <canvas ref={canvasRef} />
      </div>
    </div>
  )
}
